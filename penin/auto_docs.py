"""
Auto-Documentation Generator
===========================

Generates living documentation for PENIN-Ω system.
Creates README_AUTO.md with system status, modules, and roadmap.
"""

import os
import time
import json
from pathlib import Path
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
import orjson


@dataclass
class ModuleInfo:
    """Information about a system module"""
    name: str
    path: str
    description: str
    status: str  # "active", "inactive", "testing", "deprecated"
    version: str
    dependencies: List[str] = field(default_factory=list)
    metrics: Dict[str, Any] = field(default_factory=dict)
    last_updated: float = field(default_factory=time.time)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "path": self.path,
            "description": self.description,
            "status": self.status,
            "version": self.version,
            "dependencies": self.dependencies,
            "metrics": self.metrics,
            "last_updated": self.last_updated
        }


@dataclass
class SystemStatus:
    """Overall system status"""
    timestamp: float
    version: str
    status: str  # "healthy", "warning", "critical", "failed"
    modules_count: int
    active_modules: int
    total_evolutions: int
    last_evolution: float
    metrics: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp,
            "version": self.version,
            "status": self.status,
            "modules_count": self.modules_count,
            "active_modules": self.active_modules,
            "total_evolutions": self.total_evolutions,
            "last_evolution": self.last_evolution,
            "metrics": self.metrics
        }


class AutoDocumentationGenerator:
    """Generates living documentation for PENIN-Ω"""
    
    def __init__(self, output_dir: Optional[Path] = None):
        if output_dir is None:
            output_dir = Path.cwd()
        
        self.output_dir = output_dir
        self.readme_file = output_dir / "README_AUTO.md"
        
        # Module registry
        self.modules: Dict[str, ModuleInfo] = {}
        
        # System status
        self.system_status: Optional[SystemStatus] = None
        
        # Documentation templates
        self.templates = self._load_templates()
        
        # History tracking
        self.documentation_history: List[Dict[str, Any]] = []
        self.max_history = 100
    
    def _load_templates(self) -> Dict[str, str]:
        """Load documentation templates"""
        return {
            "header": """# PENIN-Ω Auto-Documentation

> **Generated**: {timestamp}  
> **Version**: {version}  
> **Status**: {status}  
> **Evolutions**: {total_evolutions}

## System Overview

PENIN-Ω is an advanced evolutionary AI system implementing the Life Equation (+) and multiple cognitive modules for safe, controlled evolution.

### Core Principles

- **Fail-Closed**: Any gate failure prevents promotion
- **Non-Compensatory**: All conditions must be met
- **CPU-First**: Operates without GPU requirements
- **WORM + Merkle**: Immutable ledger for all changes
- **ΣEA/LO-14**: Adherence to ethical and operational invariants

""",
            
            "modules": """## System Modules

### Core Evolution Engine

| Module | Status | Version | Description |
|--------|--------|---------|-------------|
{core_modules}

### Advanced Cognitive Modules

| Module | Status | Version | Description |
|--------|--------|---------|-------------|
{advanced_modules}

### Safety & Monitoring

| Module | Status | Version | Description |
|--------|--------|---------|-------------|
{safety_modules}

""",
            
            "metrics": """## System Metrics

### Current Performance

{current_metrics}

### Evolution History

{evolution_history}

""",
            
            "roadmap": """## Development Roadmap

### Completed Features

{completed_features}

### In Progress

{in_progress_features}

### Planned Features

{planned_features}

### Future Considerations

{future_considerations}

""",
            
            "footer": """## System Information

- **Documentation Generated**: {timestamp}
- **Total Modules**: {modules_count}
- **Active Modules**: {active_modules}
- **System Uptime**: {uptime}
- **Last Evolution**: {last_evolution}

---

*This documentation is automatically generated by the PENIN-Ω system. For manual updates, modify the source code and regenerate.*

"""
        }
    
    def register_module(self, module_info: ModuleInfo) -> None:
        """Register a module for documentation"""
        self.modules[module_info.name] = module_info
    
    def update_system_status(self, status: SystemStatus) -> None:
        """Update system status"""
        self.system_status = status
    
    def generate_documentation(self) -> str:
        """Generate complete documentation"""
        if not self.system_status:
            self._create_default_system_status()
        
        # Generate sections
        header = self._generate_header()
        modules_section = self._generate_modules_section()
        metrics_section = self._generate_metrics_section()
        roadmap_section = self._generate_roadmap_section()
        footer = self._generate_footer()
        
        # Combine sections
        documentation = header + modules_section + metrics_section + roadmap_section + footer
        
        return documentation
    
    def _create_default_system_status(self) -> None:
        """Create default system status if none exists"""
        self.system_status = SystemStatus(
            timestamp=time.time(),
            version="1.0.0",
            status="healthy",
            modules_count=len(self.modules),
            active_modules=len([m for m in self.modules.values() if m.status == "active"]),
            total_evolutions=0,
            last_evolution=0.0,
            metrics={}
        )
    
    def _generate_header(self) -> str:
        """Generate documentation header"""
        status = self.system_status
        return self.templates["header"].format(
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(status.timestamp)),
            version=status.version,
            status=status.status.upper(),
            total_evolutions=status.total_evolutions
        )
    
    def _generate_modules_section(self) -> str:
        """Generate modules section"""
        # Categorize modules
        core_modules = []
        advanced_modules = []
        safety_modules = []
        
        for module in self.modules.values():
            if module.name in ["life_eq", "guards", "caos", "sr", "scoring", "runners"]:
                core_modules.append(module)
            elif module.name in ["fractal", "swarm", "market", "neural_chain", "self_rag", "api_metabolizer"]:
                advanced_modules.append(module)
            else:
                safety_modules.append(module)
        
        # Generate module tables
        core_table = self._generate_module_table(core_modules)
        advanced_table = self._generate_module_table(advanced_modules)
        safety_table = self._generate_module_table(safety_modules)
        
        return self.templates["modules"].format(
            core_modules=core_table,
            advanced_modules=advanced_table,
            safety_modules=safety_table
        )
    
    def _generate_module_table(self, modules: List[ModuleInfo]) -> str:
        """Generate module table"""
        if not modules:
            return "| *No modules* | *N/A* | *N/A* | *N/A* |"
        
        table_rows = []
        for module in modules:
            status_emoji = {
                "active": "✅",
                "inactive": "❌",
                "testing": "🧪",
                "deprecated": "⚠️"
            }.get(module.status, "❓")
            
            row = f"| {module.name} | {status_emoji} {module.status} | {module.version} | {module.description} |"
            table_rows.append(row)
        
        return "\n".join(table_rows)
    
    def _generate_metrics_section(self) -> str:
        """Generate metrics section"""
        if not self.system_status:
            return "## System Metrics\n\n*No metrics available*\n\n"
        
        # Current metrics
        current_metrics = self._format_metrics(self.system_status.metrics)
        
        # Evolution history (placeholder)
        evolution_history = "*Evolution history will be populated as the system runs*\n"
        
        return self.templates["metrics"].format(
            current_metrics=current_metrics,
            evolution_history=evolution_history
        )
    
    def _format_metrics(self, metrics: Dict[str, Any]) -> str:
        """Format metrics for display"""
        if not metrics:
            return "*No current metrics available*\n"
        
        formatted = []
        for key, value in metrics.items():
            if isinstance(value, (int, float)):
                formatted.append(f"- **{key}**: {value:.4f}")
            else:
                formatted.append(f"- **{key}**: {value}")
        
        return "\n".join(formatted) + "\n"
    
    def _generate_roadmap_section(self) -> str:
        """Generate roadmap section"""
        # Define roadmap items
        completed_features = [
            "Life Equation (+) implementation",
            "Core evolution engine",
            "Safety guards (Σ-Guard, IR→IC)",
            "CAOS+ metric calculation",
            "Self-reflection (SR-Ω∞) system",
            "L∞ non-compensatory scoring",
            "WORM + Merkle ledger",
            "Basic evolution cycle"
        ]
        
        in_progress_features = [
            "Fractal DSL propagation",
            "Swarm cognitive gossip",
            "CAOS-KRATOS exploration",
            "Marketplace cognitive system",
            "Neural blockchain (lightweight)",
            "Self-RAG recursive system",
            "API metabolization",
            "Digital immunity system",
            "Checkpoint & repair",
            "GAME gradient memory",
            "Darwinian audit",
            "Zero-consciousness proof"
        ]
        
        planned_features = [
            "Advanced swarm coordination",
            "Enhanced marketplace dynamics",
            "Sophisticated self-RAG",
            "Comprehensive immunity",
            "Advanced checkpointing",
            "Gradient optimization",
            "Evolutionary selection",
            "Consciousness monitoring"
        ]
        
        future_considerations = [
            "Multi-agent coordination",
            "Distributed evolution",
            "Advanced consciousness detection",
            "Quantum-resistant cryptography",
            "Biologically-inspired evolution",
            "Ethical AI frameworks",
            "Human-AI collaboration",
            "Autonomous system management"
        ]
        
        # Format features
        completed_list = "\n".join(f"- {feature}" for feature in completed_features)
        in_progress_list = "\n".join(f"- {feature}" for feature in in_progress_features)
        planned_list = "\n".join(f"- {feature}" for feature in planned_features)
        future_list = "\n".join(f"- {feature}" for feature in future_considerations)
        
        return self.templates["roadmap"].format(
            completed_features=completed_list,
            in_progress_features=in_progress_list,
            planned_features=planned_list,
            future_considerations=future_list
        )
    
    def _generate_footer(self) -> str:
        """Generate documentation footer"""
        if not self.system_status:
            return "## System Information\n\n*No system information available*\n"
        
        status = self.system_status
        
        # Calculate uptime (placeholder)
        uptime = "Unknown"
        
        # Format last evolution
        if status.last_evolution > 0:
            last_evolution = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(status.last_evolution))
        else:
            last_evolution = "Never"
        
        return self.templates["footer"].format(
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(status.timestamp)),
            modules_count=status.modules_count,
            active_modules=status.active_modules,
            uptime=uptime,
            last_evolution=last_evolution
        )
    
    def save_documentation(self) -> bool:
        """Save documentation to file"""
        try:
            documentation = self.generate_documentation()
            
            with open(self.readme_file, 'w', encoding='utf-8') as f:
                f.write(documentation)
            
            # Update history
            self.documentation_history.append({
                "timestamp": time.time(),
                "file_path": str(self.readme_file),
                "modules_count": len(self.modules),
                "system_status": self.system_status.to_dict() if self.system_status else None
            })
            
            # Trim history
            if len(self.documentation_history) > self.max_history:
                self.documentation_history = self.documentation_history[-self.max_history:]
            
            return True
            
        except Exception as e:
            print(f"Error saving documentation: {e}")
            return False
    
    def get_documentation_stats(self) -> Dict[str, Any]:
        """Get documentation generation statistics"""
        return {
            "total_modules": len(self.modules),
            "active_modules": len([m for m in self.modules.values() if m.status == "active"]),
            "documentation_history_count": len(self.documentation_history),
            "last_generation": self.documentation_history[-1]["timestamp"] if self.documentation_history else None,
            "readme_file": str(self.readme_file),
            "system_status": self.system_status.to_dict() if self.system_status else None
        }
    
    def export_module_registry(self) -> Dict[str, Any]:
        """Export module registry"""
        return {
            "modules": {name: module.to_dict() for name, module in self.modules.items()},
            "system_status": self.system_status.to_dict() if self.system_status else None,
            "documentation_history": self.documentation_history
        }


# Global documentation generator instance
_global_doc_generator: Optional[AutoDocumentationGenerator] = None


def get_global_doc_generator() -> AutoDocumentationGenerator:
    """Get global documentation generator instance"""
    global _global_doc_generator
    
    if _global_doc_generator is None:
        _global_doc_generator = AutoDocumentationGenerator()
    
    return _global_doc_generator


def generate_readme_auto() -> bool:
    """Convenience function to generate README_AUTO.md"""
    generator = get_global_doc_generator()
    return generator.save_documentation()


def test_auto_documentation() -> Dict[str, Any]:
    """Test auto-documentation system"""
    generator = get_global_doc_generator()
    
    # Register test modules
    test_modules = [
        ModuleInfo(
            name="life_eq",
            path="penin/omega/life_eq.py",
            description="Life Equation (+) - Non-compensatory evolution gate",
            status="active",
            version="1.0.0",
            dependencies=["guards", "caos", "sr", "scoring"]
        ),
        ModuleInfo(
            name="fractal",
            path="penin/omega/fractal.py",
            description="Fractal DSL for auto-similarity propagation",
            status="testing",
            version="0.9.0",
            dependencies=["life_eq"]
        ),
        ModuleInfo(
            name="swarm",
            path="penin/omega/swarm.py",
            description="Swarm cognitive gossip system",
            status="testing",
            version="0.9.0",
            dependencies=["fractal"]
        ),
        ModuleInfo(
            name="immunity",
            path="penin/omega/immunity.py",
            description="Digital immunity anomaly detection",
            status="active",
            version="1.0.0",
            dependencies=["life_eq"]
        )
    ]
    
    for module in test_modules:
        generator.register_module(module)
    
    # Update system status
    system_status = SystemStatus(
        timestamp=time.time(),
        version="1.0.0",
        status="healthy",
        modules_count=len(test_modules),
        active_modules=len([m for m in test_modules if m.status == "active"]),
        total_evolutions=42,
        last_evolution=time.time() - 3600,
        metrics={
            "alpha_eff": 0.02,
            "phi": 0.7,
            "sr": 0.85,
            "G": 0.9,
            "L_inf": 0.8,
            "cost": 0.02
        }
    )
    
    generator.update_system_status(system_status)
    
    # Generate and save documentation
    success = generator.save_documentation()
    
    # Get stats
    stats = generator.get_documentation_stats()
    
    return {
        "generation_success": success,
        "documentation_stats": stats,
        "readme_file_exists": generator.readme_file.exists(),
        "readme_file_size": generator.readme_file.stat().st_size if generator.readme_file.exists() else 0
    }